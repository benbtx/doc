# 六大原则

1)单一职责原则（我只做一件事情）
2)里氏替换原则
3)依赖倒转原则
4)接口隔离原则
5)迪米特法则
6)开闭原则

# 为什么要使用设计模式
 > 开发人员A碰到了一个问题，就找开发B,开发B说用"xxxx设计模式就行了"，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”
 > 但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。
# 五大创建型模式
 * 创建型模式：单例模式
 > 参考jq的$的实例化，保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）。
 * 工厂模式(Simple Factory)
 >  这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。
 ```
 var request1 = ajax('cgi.xx.com/xxx' , ''get' );
 
request1.start();
 
request1.done( fn );
 
var request2 = ajax('cgi.xx.com/xxx' , ''jsonp' );
 
request2.start();
 
request2.done( fn );
 ```
 > 缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式
* ## 抽象工厂(Abstract Factory)
  > ​工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。
* 建造者模式（Builder Pattern）
  1.简述：将一个复杂对象的--构建--与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象
  2.代码
  ```
  // #建造者模式 


// 抽象建造者
var Car = function (param) {
    // 速度
    this.speed = param && param.speed || '0';
    // 重量
    this.weight = param && param.weight || '0';
}


Car.prototype = {
    // 获取速度
    getSpeed: function () {
        return this.speed;
    },
    // 获取重量
    getWeight: function () {
        return this.weight
    }
}

// 轮胎部件类
var Tyre = function (type) {
    var that = this;
    // 构造器
    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸
    (function (type,that) {
        switch (type) {
            case 'small':
            that.tyre = '小号轮胎';
            that.tyreIntro = '正在使用小号轮胎';
            break;
            case 'normal':
            that.tyre = '中号轮胎';
            that.tyreIntro = '正在使用中号轮胎';
            break;
            case 'big':
            that.tyre = '大号轮胎';
            that.tyreIntro = '正在使用大号轮胎';
            break;
        }
    })(type,this);
}


Tyre.prototype = {
    // 更换轮胎的方法
    changeType: function (type) {
        that.tyre = type;
        that.tyreIntro = '正在使用'+type;
    }
}


// 发动机部件类
var Engine = function (type) {
    var that = this;
    // 构造器
    // 构造函数中通过传入的type类型设置相对应的发动机类型
    (function (type,that) {
        switch (type) {
            case 'small':
            that.engine = '小号发动机';
            that.engineIntro = '正在使用小号发动机';
            break;
            case 'normal':
            that.engine = '中号发动机';
            that.engineIntro = '正在使用中号发动机';
            break;
            case 'big':
            that.engine = '大号发动机';
            that.engineIntro = '正在使用大号发动机';
            break;
        }
    })(type,this);
}


Engine.prototype = {
    // 更换发动机的方法
    changeType: function (type) {
        that.engine = type;
        that.engineIntro = '正在使用'+type;
    }
}

/**
 * 指挥者,建造一个奔驰车的类
 * @param {*轮胎类型 small normal big} tyre 
 * @param {*发动机类型 small normal big} engine 
 * @param {*车辆基本属性 param.speed:速度 param.weight: 重量} param 
 */
var BenChi = function (tyre,engine,param) {
    // 创建一个车辆缓存对象
    var _car = new Car(param);
    // 创建车辆的轮胎
    _car.tyreInfo = new Tyre(tyre);
    // 创建车辆的发动机
    _car.engineInfo = new Engine(engine);
    // 将创建的车辆对象返回
    return _car;
}

// 具体建造者 实例化奔驰车类
var benchi1 = new BenChi('small','big',{speed: 200,weight: '200'});
console.log(benchi1.speed);// 200
console.log(benchi1.weight);// 200
console.log(benchi1.tyreInfo.tyre);// 小号轮胎
console.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎
console.log(benchi1.engineInfo.engine);// 大号发动机
console.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机
  ```
  3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
  4.缺点
  5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”