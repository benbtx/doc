[TOC]



# 六大原则

1)单一职责原则（我只做一件事情）
2)里氏替换原则
3)依赖倒转原则
4)接口隔离原则
5)迪米特法则
6)开闭原则

# 为什么要使用设计模式
 > 开发人员A碰到了一个问题，就找开发B,开发B说用"xxxx设计模式就行了"，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”
 > 但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。
# 五大创建型模式
 * 创建型模式：单例模式
 > 参考jq的$的实例化，保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）。
 * 工厂模式(Simple Factory)
 >  这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。
 ```
 var request1 = ajax('cgi.xx.com/xxx' , ''get' );
 
request1.start();
 
request1.done( fn );
 
var request2 = ajax('cgi.xx.com/xxx' , ''jsonp' );
 
request2.start();
 
request2.done( fn );
 ```
 > 缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式
* ## 抽象工厂(Abstract Factory)
  > 工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。
* 建造者模式（Builder Pattern）
  1.简述：将一个复杂对象的--构建--与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象``
  2.代码
  ```
  // #建造者模式 
  ```


// 抽象建造者
var Car = function (param) {
    // 速度
    this.speed = param && param.speed || '0';
    // 重量
    this.weight = param && param.weight || '0';
}


Car.prototype = {
    // 获取速度
    getSpeed: function () {
        return this.speed;
    },
    // 获取重量
    getWeight: function () {
        return this.weight
    }
}

// 轮胎部件类
var Tyre = function (type) {
    var that = this;
    // 构造器
    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸
    (function (type,that) {
        switch (type) {
            case 'small':
            that.tyre = '小号轮胎';
            that.tyreIntro = '正在使用小号轮胎';
            break;
            case 'normal':
            that.tyre = '中号轮胎';
            that.tyreIntro = '正在使用中号轮胎';
            break;
            case 'big':
            that.tyre = '大号轮胎';
            that.tyreIntro = '正在使用大号轮胎';
            break;
        }
    })(type,this);
}


Tyre.prototype = {
    // 更换轮胎的方法
    changeType: function (type) {
        that.tyre = type;
        that.tyreIntro = '正在使用'+type;
    }
}


// 发动机部件类
var Engine = function (type) {
    var that = this;
    // 构造器
    // 构造函数中通过传入的type类型设置相对应的发动机类型
    (function (type,that) {
        switch (type) {
            case 'small':
            that.engine = '小号发动机';
            that.engineIntro = '正在使用小号发动机';
            break;
            case 'normal':
            that.engine = '中号发动机';
            that.engineIntro = '正在使用中号发动机';
            break;
            case 'big':
            that.engine = '大号发动机';
            that.engineIntro = '正在使用大号发动机';
            break;
        }
    })(type,this);
}


Engine.prototype = {
    // 更换发动机的方法
    changeType: function (type) {
        that.engine = type;
        that.engineIntro = '正在使用'+type;
    }
}

/**
 * 指挥者,建造一个奔驰车的类
 * @param {*轮胎类型 small normal big} tyre 
 * @param {*发动机类型 small normal big} engine 
 * @param {*车辆基本属性 param.speed:速度 param.weight: 重量} param 
 */
var BenChi = function (tyre,engine,param) {
    // 创建一个车辆缓存对象
    var _car = new Car(param);ckplayer 隐藏控制
    // 创建车辆的轮胎
    _car.tyreInfo = new Tyre(tyre);
    // 创建车辆的发动机
    _car.engineInfo = new Engine(engine);
    // 将创建的车辆对象返回
    return _car;
}

// 具体建造者 实例化奔驰车类
var benchi1 = new BenChi('small','big',{speed: 200,weight: '200'});
console.log(benchi1.speed);// 200
console.log(benchi1.weight);// 200
console.log(benchi1.tyreInfo.tyre);// 小号轮胎
console.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎
console.log(benchi1.engineInfo.engine);// 大号发动机
console.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机
  ```
  3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
  4.缺点
  5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”
  ```

## 原型模式

减少new，使用create直接创建对象。

# 行为型模式

## 模版方式

>类似管控的视频模块，应该要使用这个模式,就是预设好具体的口子给继承方使用。
>
>1.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。
>
>2.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。
>
>3.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。

  ```javascript
/* 抽象父类：饮料 */
var Beverage = function(){};
// (1) 把水煮沸
Beverage.prototype.boilWater = function() {
    console.log("把水煮沸");
};
// (2) 沸水浸泡
Beverage.prototype.brew = function() {
    throw new Error("子类必须重写brew方法");
};
// (3) 倒进杯子
Beverage.prototype.pourInCup = function() {
    throw new Error("子类必须重写pourInCup方法");
};
// (4) 加调料
Beverage.prototype.addCondiments = function() {
    throw new Error("子类必须重写addCondiments方法");
};

/* 模板方法 */
Beverage.prototype.init = function() {
    this.boilWater();
    this.brew();
    this.pourInCup();
    this.addCondiments();
}

/* 实现子类 Coffee*/
var Coffee = function(){};
Coffee.prototype = new Beverage();
// 重写非公有方法
Coffee.prototype.brew = function() {
    console.log("用沸水冲泡咖啡");
};
Coffee.prototype.pourInCup = function() {
    console.log("把咖啡倒进杯子");
};
Coffee.prototype.addCondiments = function() {
    console.log("加牛奶");
};
var coffee = new Coffee();
coffee.init();

  ```

通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。
如上述流程，加调料是可选的。
钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。

```javascript
/* 添加钩子方法 */
Beverage.prototype.customerWantsCondiments = function() {
    return true;
};
Beverage.prototype.init = function() {
    this.boilWater();
    this.brew();
    this.pourInCup();
    if(this.customerWantsCondiments()) {
        this.addCondiments();
    }
}

/* 实现子类 Tea*/
var Tea = function(){};
Tea.prototype = new Beverage();
// 重写非公有方法
Tea.prototype.brew = function() {
    console.log("用沸水冲泡茶");
};
Tea.prototype.pourInCup = function() {
    console.log("把茶倒进杯子");
};
Tea.prototype.addCondiments = function() {
    console.log("加牛奶");
};
Tea.prototype.customerWantsCondiments = function() {
    return window.confirm("需要添加调料吗？");
};
var tea = new Tea();
tea.init();
```

JavaScript没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。